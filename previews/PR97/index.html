<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TemporalGPs.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TemporalGPs.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/approx_space_time_inference/">-</a></li><li><a class="tocitem" href="examples/approx_space_time_learning/">-</a></li><li><a class="tocitem" href="examples/augmented_inference/">-</a></li><li><a class="tocitem" href="examples/exact_space_time_inference/">-</a></li><li><a class="tocitem" href="examples/exact_space_time_learning/">-</a></li><li><a class="tocitem" href="examples/exact_time_inference/">-</a></li><li><a class="tocitem" href="examples/exact_time_learning/">-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TemporalGPs.jl"><a class="docs-heading-anchor" href="#TemporalGPs.jl">TemporalGPs.jl</a><a id="TemporalGPs.jl-1"></a><a class="docs-heading-anchor-permalink" href="#TemporalGPs.jl" title="Permalink"></a></h1><ul><li><a href="#ChainRulesCore.ProjectTo-Tuple{FillArrays.Fill}"><code>ChainRulesCore.ProjectTo</code></a></li><li><a href="#TemporalGPs.AbstractLGC"><code>TemporalGPs.AbstractLGC</code></a></li><li><a href="#TemporalGPs.BottleneckLGC"><code>TemporalGPs.BottleneckLGC</code></a></li><li><a href="#TemporalGPs.DTCSeparable"><code>TemporalGPs.DTCSeparable</code></a></li><li><a href="#TemporalGPs.ElementOfLGSSM"><code>TemporalGPs.ElementOfLGSSM</code></a></li><li><a href="#TemporalGPs.FiniteLTISDE"><code>TemporalGPs.FiniteLTISDE</code></a></li><li><a href="#TemporalGPs.GaussMarkovModel"><code>TemporalGPs.GaussMarkovModel</code></a></li><li><a href="#TemporalGPs.Gaussian"><code>TemporalGPs.Gaussian</code></a></li><li><a href="#TemporalGPs.LGSSM"><code>TemporalGPs.LGSSM</code></a></li><li><a href="#TemporalGPs.LTISDE"><code>TemporalGPs.LTISDE</code></a></li><li><a href="#TemporalGPs.LargeOutputLGC"><code>TemporalGPs.LargeOutputLGC</code></a></li><li><a href="#TemporalGPs.RectilinearGrid"><code>TemporalGPs.RectilinearGrid</code></a></li><li><a href="#TemporalGPs.RegularInTime"><code>TemporalGPs.RegularInTime</code></a></li><li><a href="#TemporalGPs.RegularSpacing"><code>TemporalGPs.RegularSpacing</code></a></li><li><a href="#TemporalGPs.ScalarOutputLGC"><code>TemporalGPs.ScalarOutputLGC</code></a></li><li><a href="#TemporalGPs.Separable"><code>TemporalGPs.Separable</code></a></li><li><a href="#TemporalGPs.SmallOutputLGC"><code>TemporalGPs.SmallOutputLGC</code></a></li><li><a href="#TemporalGPs.SpaceTimeGrid"><code>TemporalGPs.SpaceTimeGrid</code></a></li><li><a href="#AbstractGPs.dtc-Tuple{AbstractGPs.FiniteGP{&lt;:TemporalGPs.LTISDE}, AbstractVector, AbstractVector}"><code>AbstractGPs.dtc</code></a></li><li><a href="#AbstractGPs.elbo-Tuple{AbstractGPs.FiniteGP{&lt;:TemporalGPs.LTISDE}, AbstractVector, AbstractVector}"><code>AbstractGPs.elbo</code></a></li><li><a href="#AbstractGPs.marginals-Tuple{TemporalGPs.LGSSM}"><code>AbstractGPs.marginals</code></a></li><li><a href="#TemporalGPs.approx_posterior_marginals-Tuple{typeof(AbstractGPs.dtc), AbstractGPs.FiniteGP{&lt;:TemporalGPs.LTISDE}, AbstractVector, AbstractVector, AbstractVector, Int64}"><code>TemporalGPs.approx_posterior_marginals</code></a></li><li><a href="#TemporalGPs.approx_posterior_marginals-Tuple{typeof(AbstractGPs.dtc), AbstractGPs.FiniteGP{&lt;:TemporalGPs.LTISDE}, AbstractVector, AbstractVector, AbstractVector}"><code>TemporalGPs.approx_posterior_marginals</code></a></li><li><a href="#TemporalGPs.conditional_rand-Tuple{Random.AbstractRNG, TemporalGPs.AbstractLGC, AbstractVector}"><code>TemporalGPs.conditional_rand</code></a></li><li><a href="#TemporalGPs.destructure-Tuple{AbstractVector{&lt;:Real}, AbstractVector}"><code>TemporalGPs.destructure</code></a></li><li><a href="#TemporalGPs.dtcify-Tuple{AbstractVector, Separable}"><code>TemporalGPs.dtcify</code></a></li><li><a href="#TemporalGPs.get_times-Tuple{AbstractVector{&lt;:Real}}"><code>TemporalGPs.get_times</code></a></li><li><a href="#TemporalGPs.inputs_to_time_form-Tuple{AbstractVector{&lt;:Real}}"><code>TemporalGPs.inputs_to_time_form</code></a></li><li><a href="#TemporalGPs.marginals_diag-Tuple{TemporalGPs.LGSSM}"><code>TemporalGPs.marginals_diag</code></a></li><li><a href="#TemporalGPs.merge_inputs-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>TemporalGPs.merge_inputs</code></a></li><li><a href="#TemporalGPs.noise_var_to_time_form-Tuple{AbstractVector{&lt;:Real}, LinearAlgebra.Diagonal{var&quot;#s92&quot;, V} where {var&quot;#s92&quot;&lt;:Real, V&lt;:AbstractVector{var&quot;#s92&quot;}}}"><code>TemporalGPs.noise_var_to_time_form</code></a></li><li><a href="#TemporalGPs.observations_to_time_form-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Union{Missing, Real}}}"><code>TemporalGPs.observations_to_time_form</code></a></li><li><a href="#TemporalGPs.predict-Tuple{TemporalGPs.Gaussian, TemporalGPs.AbstractLGC}"><code>TemporalGPs.predict</code></a></li><li><a href="#TemporalGPs.predict_marginals-Tuple{TemporalGPs.Gaussian, TemporalGPs.AbstractLGC}"><code>TemporalGPs.predict_marginals</code></a></li><li><a href="#TemporalGPs.scan_emit-NTuple{4, Any}"><code>TemporalGPs.scan_emit</code></a></li><li><a href="#TemporalGPs.sort_in_time-Tuple{AbstractVector{&lt;:Real}}"><code>TemporalGPs.sort_in_time</code></a></li><li><a href="#TemporalGPs.to_sde"><code>TemporalGPs.to_sde</code></a></li><li><a href="#TemporalGPs.to_sde-Union{Tuple{T}, Tuple{KernelFunctions.SimpleKernel, ArrayStorage{T}}} where T&lt;:Real"><code>TemporalGPs.to_sde</code></a></li><li><a href="#TemporalGPs.zygote_friendly_map-Tuple{Any, Any}"><code>TemporalGPs.zygote_friendly_map</code></a></li><li><a href="#TemporalGPs.ε_randn-Tuple{Random.AbstractRNG, TemporalGPs.AbstractLGC}"><code>TemporalGPs.ε_randn</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.ProjectTo-Tuple{FillArrays.Fill}" href="#ChainRulesCore.ProjectTo-Tuple{FillArrays.Fill}"><code>ChainRulesCore.ProjectTo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ProjectTo(::Fill) -&gt; ProjectTo{Fill}
ProjectTo(::Ones) -&gt; ProjectTo{NoTangent}</code></pre><p>Most FillArrays arrays store one number, and so their gradients under automatic differentiation represent the variation of this one number. </p><p>The exception is those like <code>Ones</code> and <code>Zeros</code> whose type fixes their value, which have no graidient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/util/chainrules.jl#LL102-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.AbstractLGC" href="#TemporalGPs.AbstractLGC"><code>TemporalGPs.AbstractLGC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLGC</code></pre><p>Represents a Gaussian conditional distribution:</p><pre><code class="language-julia hljs">y | x ∼ Gaussian(A * x + a, Q)</code></pre><p>Note that this can be used in two contexts:</p><ul><li>Transition: <code>y</code> is the next state, <code>x</code> is the current state.</li><li>Emission: <code>y</code> is the observation, <code>x</code> is the state.</li></ul><p>Subtypes have discretion over how to implement the interface for this type. In particular <code>A</code>, <code>a</code>, and <code>Q</code> may not be represented explicitly so that structure can be exploited to accelerate computations.</p><p><strong>Interface:</strong></p><ul><li><code>==</code></li><li><code>eltype</code></li><li><code>dim_out</code></li><li><code>dim_in</code></li><li><code>predict</code></li><li><code>predict_marginals</code></li><li><code>conditional_rand</code></li><li><code>ε_randn</code></li><li><code>posterior_and_lml</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/linear_gaussian_conditionals.jl#LL1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.BottleneckLGC" href="#TemporalGPs.BottleneckLGC"><code>TemporalGPs.BottleneckLGC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BottleneckLGC</code></pre><p>A composition of an affine map that projects onto a low-dimensional subspace and a <a href="#TemporalGPs.LargeOutputLGC"><code>LargeOutputLGC</code></a>. This structure is exploited by only ever computing <code>Cholesky</code> factorisations in the space the affine map maps to, rather than the input or output space.</p><p>Letting, <code>H</code> and <code>h</code> parametrise the affine map, and <code>f</code> the &quot;fan-out&quot; <a href="#TemporalGPs.LargeOutputLGC"><code>LargeOutputLGC</code></a>, the conditional distribution that this model parametrises is</p><pre><code class="language-julia hljs">y | x ~ Gaussian(f.A * (H * x + h) + f.a, f.Q)</code></pre><p>Note that this type does not enforce that <code>size(H, 1) &lt; size(H, 2)</code>, nor that <code>dim_out(f) &gt; dim_in(f)</code>, it&#39;s just not a particularly good idea to use this type unless your model satisfies these properties.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/linear_gaussian_conditionals.jl#LL290-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.DTCSeparable" href="#TemporalGPs.DTCSeparable"><code>TemporalGPs.DTCSeparable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DTCSeparable{Tz&lt;:AbstractVector, Tk&lt;:SeparableKernel} &lt;: Kernel</code></pre><p>Specifies a low-rank approximation to a kernel <code>k</code> through pseudo-inputs <code>z</code>. <code>z</code> are the locations of the pseudo-inputs in <em>space</em>, since they are automatically replicated (implicitly) at each point in time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/space_time/pseudo_point.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.ElementOfLGSSM" href="#TemporalGPs.ElementOfLGSSM"><code>TemporalGPs.ElementOfLGSSM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElementOfLGSSM</code></pre><p>Represents an element of <a href="#TemporalGPs.LGSSM"><code>LGSSM</code></a> with a given ordering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/lgssm.jl#LL50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.FiniteLTISDE" href="#TemporalGPs.FiniteLTISDE"><code>TemporalGPs.FiniteLTISDE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const FiniteLTISDE = FiniteGP{&lt;:LTISDE}</code></pre><p>A <code>FiniteLTISDE</code> is just a regular <code>FiniteGP</code> that happens to contain an <code>LTISDE</code>, as opposed to any other <code>AbstractGP</code>, useful for dispatching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/gp/lti_sde.jl#LL24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.GaussMarkovModel" href="#TemporalGPs.GaussMarkovModel"><code>TemporalGPs.GaussMarkovModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussMarkovModel</code></pre><p>Specifies the following Gauss-Markov model.</p><pre><code class="language-julia hljs">x[0] ∼ x0
x[t] = A[t] * x[t-1] + a[t] + ε[t], ε[t] ∼ N(0, Q)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/gauss_markov_model.jl#LL11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.Gaussian" href="#TemporalGPs.Gaussian"><code>TemporalGPs.Gaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Gaussian{Tm, TP}</code></pre><p>A (multivariate) Gaussian with mean vector <code>m</code> and variance matrix <code>P</code>. This doesn&#39;t currently conform to Distributions.jl standards. Work to make this happen would be welcomed.</p><p>It was necessary to implement this a year or so ago for AD-related reasons. It&#39;s quite possible that in the intervening period of time things have improved and this type is no longer necessary in addition to the <code>MvNormal</code> type in <code>Distributions</code>. I&#39;ve not had the time to remove it though.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/util/gaussian.jl#LL4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.LGSSM" href="#TemporalGPs.LGSSM"><code>TemporalGPs.LGSSM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LGSSM{Ttransitions&lt;:GaussMarkovModel, Temissions&lt;:StructArray} &lt;: AbstractLGSSM</code></pre><p>A Linear-Gaussian State-Space model. Represented in terms of a Gauss-Markov model <code>transitions</code> and collection of emission dynamics <code>emissions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/lgssm.jl#LL3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.LTISDE" href="#TemporalGPs.LTISDE"><code>TemporalGPs.LTISDE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LTISDE (Linear Time-Invariant Stochastic Differential Equation)</code></pre><p>A lightweight wrapper around a <code>GP</code> <code>f</code> that tells this package to handle inference in <code>f</code>. Can be constructed via the <a href="#TemporalGPs.to_sde"><code>to_sde</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/gp/lti_sde.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.LargeOutputLGC" href="#TemporalGPs.LargeOutputLGC"><code>TemporalGPs.LargeOutputLGC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LargeOutputLGC{
    TA&lt;:AbstractMatrix, Ta&lt;:AbstractVector, TQ&lt;:AbstractMatrix,
} &lt;: AbstractLGC</code></pre><p>A <a href="#TemporalGPs.SmallOutputLGC"><code>SmallOutputLGC</code></a> (LGC) specialised for models in which the dimension of the outputs are greater than that of the inputs. These specialisations both improve numerical stability and performance (time and memory), so it&#39;s worth using if your model lives in this regime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/linear_gaussian_conditionals.jl#LL161-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.RectilinearGrid" href="#TemporalGPs.RectilinearGrid"><code>TemporalGPs.RectilinearGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectilinearGrid{Tl, Tr} &lt;: AbstractVector{Tuple{Tl, Tr}}</code></pre><p>A <code>RectilinearGrid</code> is parametrised by <code>AbstractVector</code>s of points <code>xl</code> and <code>xr</code>, whose element types are <code>Tl</code> and <code>Tr</code> respectively, comprising <code>length(xl) * length(xr)</code> elements. Linear indexing is the same as <code>product(eachindex(xl), eachindex(xr))</code> - <code>xl</code> iterates more quickly than <code>xr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/space_time/rectilinear_grid.jl#LL3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.RegularInTime" href="#TemporalGPs.RegularInTime"><code>TemporalGPs.RegularInTime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularInTime{
    Tt, Tv, Tts&lt;:AbstractVector{Tt}, Tvs&lt;:AbstractVector{&lt;:AbstractVector{Tv}},
} &lt;: AbstractVector{Tuple{Tt, Tv}}</code></pre><p>Represents data that has multiple observations at each of a given collection of time slices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/space_time/regular_in_time.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.RegularSpacing" href="#TemporalGPs.RegularSpacing"><code>TemporalGPs.RegularSpacing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularSpacing{T&lt;:Real} &lt;: AbstractVector{T}</code></pre><p><code>RegularSpacing(t0, Δt, N)</code> represents the same thing as <code>range(t0; step=Δt, length=N)</code>, but has a different implementation that makes it possible to differentiate through with the current version of <code>Zygote</code>. This data structure will be entirely removed once it&#39;s possible to work with <code>StepRangeLen</code>s in <code>Zygote</code>.</p><p>Relevant issue: https://github.com/FluxML/Zygote.jl/issues/550</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/util/regular_data.jl#LL1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.ScalarOutputLGC" href="#TemporalGPs.ScalarOutputLGC"><code>TemporalGPs.ScalarOutputLGC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarOutputLGC</code></pre><p>An <a href="#TemporalGPs.AbstractLGC"><code>AbstractLGC</code></a> that operates on a vector-valued input space and a scalar-valued output space. Similar to <a href="#TemporalGPs.SmallOutputLGC"><code>SmallOutputLGC</code></a> when its <code>dim_out</code> is 1 but, for example, <a href="#TemporalGPs.conditional_rand-Tuple{Random.AbstractRNG, TemporalGPs.AbstractLGC, AbstractVector}"><code>conditional_rand</code></a> returns a <code>Real</code> rather than an <code>AbstractVector</code> of length 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/linear_gaussian_conditionals.jl#LL241-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.Separable" href="#TemporalGPs.Separable"><code>TemporalGPs.Separable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Separable{Tl&lt;:Kernel, Tr&lt;:Kernel} &lt;: Kernel</code></pre><p>The kernel <code>k</code> given by</p><pre><code class="language-julia hljs">k((xl, xr), (yl, yr)) = k.l(xl, yl) * k.r(xr, yr)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/space_time/separable_kernel.jl#LL1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.SmallOutputLGC" href="#TemporalGPs.SmallOutputLGC"><code>TemporalGPs.SmallOutputLGC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SmallOutputLGC{
    TA&lt;:AbstractMatrix, Ta&lt;:AbstractVector, TQ&lt;:AbstractMatrix,
} &lt;: AbstractLGC</code></pre><p>a.k.a. LGC. An <a href="#TemporalGPs.AbstractLGC"><code>AbstractLGC</code></a> designed for problems in which <code>A</code> is a matrix, and <code>size(A, 1) &lt; size(A, 2)</code>. It should still work (roughly) for problems in which <code>size(A, 1) &gt; size(A, 2)</code>, but one should expect worse accuracy and performance than a <a href="#TemporalGPs.LargeOutputLGC"><code>LargeOutputLGC</code></a> in such circumstances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/linear_gaussian_conditionals.jl#LL106-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.SpaceTimeGrid" href="#TemporalGPs.SpaceTimeGrid"><code>TemporalGPs.SpaceTimeGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpaceTimeGrid{Tr, Tt&lt;:Real}</code></pre><p>A <code>SpaceTimeGrid</code> is a <code>RectilinearGrid</code> in which the left vector corresponds to space, and the right <code>time</code>. The left eltype is arbitrary, but the right must be <code>Real</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/space_time/rectilinear_grid.jl#LL39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractGPs.dtc-Tuple{AbstractGPs.FiniteGP{&lt;:TemporalGPs.LTISDE}, AbstractVector, AbstractVector}" href="#AbstractGPs.dtc-Tuple{AbstractGPs.FiniteGP{&lt;:TemporalGPs.LTISDE}, AbstractVector, AbstractVector}"><code>AbstractGPs.dtc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dtc(fx::FiniteLTISDE, y::AbstractVector{&lt;:Real}, z_r::AbstractVector)</code></pre><p>Compute the DTC (Deterministic Training Conditional) in state-space form [insert reference].</p><p><code>fx</code> and <code>y</code> are the same as would be provided to <code>logpdf</code>, and <code>z_r</code> is a specification of the spatial location of the pseudo-points at each point in time.</p><p>Note that this API is slightly different from AbstractGPS.jl&#39;s API, in which <code>z_r</code> is replaced by a <code>FiniteGP</code>.</p><p>WARNING: this API is unstable, and subject to change in future versions of TemporalGPs. It was thrown together quickly in pursuit of a conference deadline, and has yet to receive the attention it deserves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/space_time/pseudo_point.jl#LL38-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractGPs.elbo-Tuple{AbstractGPs.FiniteGP{&lt;:TemporalGPs.LTISDE}, AbstractVector, AbstractVector}" href="#AbstractGPs.elbo-Tuple{AbstractGPs.FiniteGP{&lt;:TemporalGPs.LTISDE}, AbstractVector, AbstractVector}"><code>AbstractGPs.elbo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elbo(fx::FiniteLTISDE, y::AbstractVector{&lt;:Real}, z_r::AbstractVector)</code></pre><p>Compute the ELBO (Evidence Lower BOund) in state-space form [insert reference].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/space_time/pseudo_point.jl#LL60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractGPs.marginals-Tuple{TemporalGPs.LGSSM}" href="#AbstractGPs.marginals-Tuple{TemporalGPs.LGSSM}"><code>AbstractGPs.marginals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginals(model::LGSSM)</code></pre><p>Compute the complete marginals at each point in time. These are returned as a <code>Vector</code> of length <code>length(model)</code>, each element of which is a dense <code>Gaussian</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/lgssm.jl#LL106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.approx_posterior_marginals-Tuple{typeof(AbstractGPs.dtc), AbstractGPs.FiniteGP{&lt;:TemporalGPs.LTISDE}, AbstractVector, AbstractVector, AbstractVector, Int64}" href="#TemporalGPs.approx_posterior_marginals-Tuple{typeof(AbstractGPs.dtc), AbstractGPs.FiniteGP{&lt;:TemporalGPs.LTISDE}, AbstractVector, AbstractVector, AbstractVector, Int64}"><code>TemporalGPs.approx_posterior_marginals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approx_posterior_marginals(
    ::typeof(dtc),
    fx::FiniteLTISDE,
    y::AbstractVector,
    z_r::AbstractVector,
    x_r::AbstractVector,
    t::Int,
)</code></pre><p>Same as other method, but only returns the predictions at index <code>t</code> in <code>fx</code>.</p><p>As with the other method of this function, it&#39;s a bit of a hack. It&#39;s correct of course, but needs to be tidied up at some point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/space_time/pseudo_point.jl#LL271-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.approx_posterior_marginals-Tuple{typeof(AbstractGPs.dtc), AbstractGPs.FiniteGP{&lt;:TemporalGPs.LTISDE}, AbstractVector, AbstractVector, AbstractVector}" href="#TemporalGPs.approx_posterior_marginals-Tuple{typeof(AbstractGPs.dtc), AbstractGPs.FiniteGP{&lt;:TemporalGPs.LTISDE}, AbstractVector, AbstractVector, AbstractVector}"><code>TemporalGPs.approx_posterior_marginals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approx_posterior_marginals(
    ::typeof(dtc),
    fx::FiniteLTISDE,
    y::AbstractVector,
    z_r::AbstractVector,
    x_r::AbstractVector,
)</code></pre><p>Compute the DTC (Deterministic Training Conditional) approximation to the posterior marginals at the times provided by <code>fx</code>, but at the new spatial locations <code>x_r</code>, given observations <code>y</code> and spatial pseudo-input locations <code>z_r</code>.</p><p>WARNING: this API is unstable, and subject to change in future versions of TemporalGPs. It was thrown together quickly in pursuit of a conference deadline, and has yet to receive the attention it deserves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/space_time/pseudo_point.jl#LL233-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.conditional_rand-Tuple{Random.AbstractRNG, TemporalGPs.AbstractLGC, AbstractVector}" href="#TemporalGPs.conditional_rand-Tuple{Random.AbstractRNG, TemporalGPs.AbstractLGC, AbstractVector}"><code>TemporalGPs.conditional_rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conditional_rand(rng::AbstractRNG, f::AbstractLGC, x::AbstractVector)
conditional_rand(ε::AbstractVector, f::AbstractLGC, x::AbstractVector)</code></pre><p>Sample from the conditional distribution <code>y | x</code>. <code>ε</code> is the randomness needed to generate this sample. If <code>rng</code> is provided, it will be used to construct <code>ε</code> via <a href="#TemporalGPs.ε_randn-Tuple{Random.AbstractRNG, TemporalGPs.AbstractLGC}"><code>ε_randn</code></a>.</p><p>If implementing a new <code>AbstractLGC</code>, implement the <code>ε</code> method as it avoids randomness, which means that it plays nicely with <code>scan_emit</code>&#39;s checkpointed rrule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/linear_gaussian_conditionals.jl#LL69-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.destructure-Tuple{AbstractVector{&lt;:Real}, AbstractVector}" href="#TemporalGPs.destructure-Tuple{AbstractVector{&lt;:Real}, AbstractVector}"><code>TemporalGPs.destructure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">destructure(x::AbstractVector, ys::AbstractVector)</code></pre><p>Construct a flattened representation of <code>ys</code> in accordance with the structure in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/gp/data_representations.jl#LL75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.dtcify-Tuple{AbstractVector, Separable}" href="#TemporalGPs.dtcify-Tuple{AbstractVector, Separable}"><code>TemporalGPs.dtcify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dtcify(z::AbstractVector, x)</code></pre><p>Recurse through <code>x</code> and replace any <code>Separable</code> kernels with a <code>DTCSeparable</code>. The resulting kernel can be used to construct the approximate model utilised by the DTC, and is used to compute the ELBO.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/space_time/pseudo_point.jl#LL13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.get_times-Tuple{AbstractVector{&lt;:Real}}" href="#TemporalGPs.get_times-Tuple{AbstractVector{&lt;:Real}}"><code>TemporalGPs.get_times</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_times(x::AbstractVector{&lt;:Real})</code></pre><p>Get the times associated with the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/gp/data_representations.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.inputs_to_time_form-Tuple{AbstractVector{&lt;:Real}}" href="#TemporalGPs.inputs_to_time_form-Tuple{AbstractVector{&lt;:Real}}"><code>TemporalGPs.inputs_to_time_form</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inputs_to_time_form(x::AbstractVector)</code></pre><p>Get the time-form representation of a vector of inputs. Outputs an <code>AbstractVector</code> whose length is <code>length(get_times(x))</code>, and whose elements comprise all of those associated with each time point.</p><p>For single-output time series problems, <code>x</code> is usually returned as-is, however, for multi-output and spatio-temporal problems there are usually multiple inputs associated with each point in time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/gp/data_representations.jl#LL8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.marginals_diag-Tuple{TemporalGPs.LGSSM}" href="#TemporalGPs.marginals_diag-Tuple{TemporalGPs.LGSSM}"><code>TemporalGPs.marginals_diag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginals_diag(model::LGSSM)</code></pre><p>Compute the diagonal of the marginals at each point in time. These are returned as a <code>Vector</code> of length <code>length(model)</code>, each element of which is a diagonal <code>Gaussian</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/lgssm.jl#LL132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.merge_inputs-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}" href="#TemporalGPs.merge_inputs-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>TemporalGPs.merge_inputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge_inputs(x1::AbstractVector, x2::AbstractVector)</code></pre><p>Merge two collections of inputs <code>x1</code> and <code>x2</code> if possible. A notable example of inputs which cannot be merged are two rectilinear grids whose spatial components differ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/gp/data_representations.jl#LL21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.noise_var_to_time_form-Tuple{AbstractVector{&lt;:Real}, LinearAlgebra.Diagonal{var&quot;#s92&quot;, V} where {var&quot;#s92&quot;&lt;:Real, V&lt;:AbstractVector{var&quot;#s92&quot;}}}" href="#TemporalGPs.noise_var_to_time_form-Tuple{AbstractVector{&lt;:Real}, LinearAlgebra.Diagonal{var&quot;#s92&quot;, V} where {var&quot;#s92&quot;&lt;:Real, V&lt;:AbstractVector{var&quot;#s92&quot;}}}"><code>TemporalGPs.noise_var_to_time_form</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noise_var_to_time_form(x::AbstractVector, S::AbstractMatrix{&lt;:Real})</code></pre><p>Get the time-form representation of an <code>AbstractMatrix</code> of observation noise variances <code>S</code>, based on the <code>AbstractVector</code> of inputs <code>x</code>.</p><p>For example, single-output time problems will typically require <code>S</code> to be <code>Diagonal</code>, and will just return its diagonal. Multi-output and spatio-temporal problems can potentially have a block-diagonal <code>S</code>, as it&#39;s typically only necessary to require that the observation variance at each point in time is independent of other times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/gp/data_representations.jl#LL60-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.observations_to_time_form-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Union{Missing, Real}}}" href="#TemporalGPs.observations_to_time_form-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Union{Missing, Real}}}"><code>TemporalGPs.observations_to_time_form</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">observations_to_time_form(x::AbstractVector, y::AbstractVector{&lt;:Real})</code></pre><p>Get the time-form representation of a vector of observations <code>y</code> of length <code>length(time_points(x))</code>, which is useful for state-space models. The precise arrangements of the elements of <code>y</code> in the output depends on <code>x</code>.</p><p>For example, single-output time-series problems typically just return <code>y</code>, but multi-output and spatio-temporal problems typically have multiple elements of <code>y</code> associated with a single element of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/gp/data_representations.jl#LL42-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.predict-Tuple{TemporalGPs.Gaussian, TemporalGPs.AbstractLGC}" href="#TemporalGPs.predict-Tuple{TemporalGPs.Gaussian, TemporalGPs.AbstractLGC}"><code>TemporalGPs.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(x::Gaussian, f::AbstractLGC)::Gaussian{Tm,AbstractMatrix}</code></pre><p>Compute the distribution &quot;predicted&quot; by this conditional given a <a href="#TemporalGPs.Gaussian"><code>Gaussian</code></a> input <code>x</code>. Will be equivalent to</p><pre><code class="language-julia hljs">    Gaussian(f.A * x.m + f.a, f.A * x.P * f.A&#39; + f.Q)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/linear_gaussian_conditionals.jl#LL36-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.predict_marginals-Tuple{TemporalGPs.Gaussian, TemporalGPs.AbstractLGC}" href="#TemporalGPs.predict_marginals-Tuple{TemporalGPs.Gaussian, TemporalGPs.AbstractLGC}"><code>TemporalGPs.predict_marginals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict_marginals(x::Gaussian, f::AbstractLGC)::Gaussian{Tm,Diagonal}</code></pre><p>Equivalent to</p><pre><code class="language-julia hljs">    xꜝ⁺¹ = predict(xꜝ, f)
    Gaussian(mean(xꜝ⁺¹), Diagonal(cov(xꜝ⁺¹)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/linear_gaussian_conditionals.jl#LL53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.scan_emit-NTuple{4, Any}" href="#TemporalGPs.scan_emit-NTuple{4, Any}"><code>TemporalGPs.scan_emit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Like Transducers.ScanEmit, but `f` isn&#39;t allowed to have internal state, and slightly
faster in some cases that I care about for this package.

This function makes some strong assumptions about the nature of `f` and `xs` so that it
can achieve good performance. In particular, `f` must not involve any globals, and
the output of `f` should not change type for different elements of `x`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/util/scan.jl#LL7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.sort_in_time-Tuple{AbstractVector{&lt;:Real}}" href="#TemporalGPs.sort_in_time-Tuple{AbstractVector{&lt;:Real}}"><code>TemporalGPs.sort_in_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_in_time(x::AbstractVector)</code></pre><p>Sort the input <code>x</code> temporally. This is different from sorting the input in general, but agrees for real-valued inputs. Returns both the sorting indices and the sorted inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/gp/data_representations.jl#LL30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.to_sde" href="#TemporalGPs.to_sde"><code>TemporalGPs.to_sde</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_sde(f::GP, storage::StorageType)</code></pre><p>Return a <a href="#TemporalGPs.LTISDE"><code>LTISDE</code></a> wrapper around <code>f</code> that allows <code>TemporalGPs</code> to  perform state-space inference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/gp/lti_sde.jl#LL12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.to_sde-Union{Tuple{T}, Tuple{KernelFunctions.SimpleKernel, ArrayStorage{T}}} where T&lt;:Real" href="#TemporalGPs.to_sde-Union{Tuple{T}, Tuple{KernelFunctions.SimpleKernel, ArrayStorage{T}}} where T&lt;:Real"><code>TemporalGPs.to_sde</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_sde(k::Kernel, storage_type::StorageType)</code></pre><p>Return the equivalent state-space representation of the kernel <code>k</code> as a tuple <code>(F, q, H)</code>, where <code>F</code> is the state transition matrix, <code>q</code> is the process noise and <code>H</code> is the observation matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/gp/lti_sde.jl#LL190-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.zygote_friendly_map-Tuple{Any, Any}" href="#TemporalGPs.zygote_friendly_map-Tuple{Any, Any}"><code>TemporalGPs.zygote_friendly_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zygote_friendly_map(f, x)</code></pre><p>This version of map is a bit weird. It makes slightly stronger assumptions about the nature of what you&#39;re allowed to pass in to it than <code>Base.map</code> does and, in return, you get much improved performance when used in conjunction with <code>Zygote</code>.</p><p><strong>Assumptions.</strong></p><ul><li>No globals are used in <code>f</code>. This means that <code>TemporalGPs.NoContext</code> can be employed.</li><li><code>f</code> has no fields. If you&#39;ve got data to share across elements, use a <code>Fill</code>.</li><li>Similarly, <code>f</code> has no mutable state (follows from the above).</li><li><code>f</code> doesn&#39;t mutate its argument.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/util/zygote_friendly_map.jl#LL1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TemporalGPs.ε_randn-Tuple{Random.AbstractRNG, TemporalGPs.AbstractLGC}" href="#TemporalGPs.ε_randn-Tuple{Random.AbstractRNG, TemporalGPs.AbstractLGC}"><code>TemporalGPs.ε_randn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ε_randn(rng::AbstractRNG, f::AbstractLGC)</code></pre><p>Generate the vector of random numbers needed inside <a href="#TemporalGPs.conditional_rand-Tuple{Random.AbstractRNG, TemporalGPs.AbstractLGC, AbstractVector}"><code>conditional_rand</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGaussianProcesses/TemporalGPs.jl/blob/61a94af415d2c76d19c8f23c758106a5cf1deea0/src/models/linear_gaussian_conditionals.jl#LL88-L92">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/approx_space_time_inference/">- »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 25 April 2023 11:55">Tuesday 25 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
